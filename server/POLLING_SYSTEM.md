# Polling система для получения ответов от AI агента

## Обзор

Поскольку n8n workflow работает асинхронно и возвращает `"Workflow was started"`, мы реализовали polling систему для получения финальных ответов от AI агента.

## Как это работает

### 1. Отправка сообщения
```
POST /api/chat/send-message
```

**Ответ:**
```json
{
  "success": true,
  "message": "Сообщение отправлено в обработку",
  "aiResponse": "Ваше сообщение получено и обрабатывается AI агентом. Ожидайте ответа...",
  "requestId": "user-123-1234567890"
}
```

### 2. Polling ответа
```
GET /api/chat/poll-response/{requestId}
```

**Ответ (если ответ готов):**
```json
{
  "success": true,
  "message": "Ответ AI агента получен",
  "aiResponse": "Привет! Я помогу вам спланировать путешествие...",
  "suggestions": ["Достопримечательности", "Отели", "Маршрут"],
  "metadata": {
    "requestId": "user-123-1234567890",
    "processingTime": 5000,
    "confidence": 0.95
  }
}
```

**Ответ (если ответ еще не готов):**
```json
{
  "success": false,
  "message": "Ответ еще не готов",
  "error": "Polling продолжается"
}
```

## Архитектура

### Серверная часть
- **Хранилище ответов** - Map для временного хранения запросов
- **Polling endpoint** - проверка готовности ответа
- **Таймаут** - 5 минут ожидания

### Клиентская часть
- **Хук usePolling** - автоматический polling
- **Интервал** - 3 секунды между запросами
- **Максимум попыток** - 10 запросов

## Настройка n8n для работы с polling

### Вариант 1: Callback webhook (Рекомендуется)

Настройте n8n workflow для отправки ответа обратно на ваш сервер:

1. **Webhook Trigger** - получает данные
2. **AI Agent** - обрабатывает сообщение
3. **HTTP Request** - отправляет ответ на callback

**Настройка callback в n8n:**
```json
{
  "method": "POST",
  "url": "http://localhost:3005/api/chat/ai-webhook",
  "body": {
    "type": "ai_response",
    "requestId": "{{ $json.requestId }}",
    "data": {
      "aiResponse": "Ответ от AI агента",
      "suggestions": ["Предложение 1", "Предложение 2"]
    }
  }
}
```

### Вариант 2: База данных

1. **Webhook Trigger** - получает данные
2. **AI Agent** - обрабатывает сообщение
3. **Database** - сохраняет ответ
4. **Polling** - читает из БД

## Тестирование

### Запуск теста polling:
```bash
cd server
node test-polling.js
```

### Тестирование через curl:
```bash
# Отправка сообщения
curl -X POST http://localhost:3005/api/chat/send-message \
  -H "Content-Type: application/json" \
  -d '{
    "message": "Привет! Помоги спланировать путешествие",
    "conversationHistory": [],
    "context": {
      "userProfile": {
        "firstName": "Тест",
        "lastName": "Пользователь"
      }
    }
  }'

# Polling ответа (замените {requestId} на полученный ID)
curl -X GET http://localhost:3005/api/chat/poll-response/{requestId} \
  -H "Content-Type: application/json"
```

## Ограничения

### Текущие ограничения:
- **Хранилище в памяти** - данные теряются при перезапуске сервера
- **Таймаут 5 минут** - после этого запрос удаляется
- **Нет аутентификации** - polling endpoint требует аутентификации

### Планы улучшения:
- **База данных** - для постоянного хранения
- **Redis** - для кэширования
- **WebSocket** - для real-time обновлений
- **Очереди** - для обработки большого количества запросов

## Отладка

### Логи сервера:
```bash
# В консоли сервера должны появиться:
Отправка сообщения AI агенту: { userId: 'user-123', ... }
Ответ от AI агента: { message: 'Workflow was started' }
Polling запрос: requestId=user-123-1234567890
```

### Проверка хранилища:
```javascript
// В консоли сервера
console.log('Хранилище ответов:', responseStore);
```

## Безопасность

### Текущие меры:
- **Аутентификация** - polling требует токена
- **Валидация** - проверка requestId
- **Таймаут** - предотвращение DoS атак

### Рекомендации:
- **Rate limiting** - ограничение частоты polling
- **Валидация данных** - проверка формата ответов
- **Логирование** - отслеживание подозрительной активности 